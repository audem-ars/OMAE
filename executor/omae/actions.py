import os, json, time, shutil, csv
from urllib.parse import urlparse

def echo(ctx, **kw):
    ctx.setdefault('log', []).append('ECHO: ' + kw.get('text','(no text)'))
    return {'ok': True}

def ensure_vite_react(dest):
    pkg={
      "name":"omae-site","private":True,"version":"0.0.1","type":"module",
      "scripts":{"dev":"vite","build":"vite build","preview":"vite preview"},
      "dependencies":{"react":"^18.2.0","react-dom":"^18.2.0"},
      "devDependencies":{"@vitejs/plugin-react":"^4.3.1","vite":"^5.3.4"}
    }
    os.makedirs(dest, exist_ok=True)
    pkg_path = os.path.join(dest, "package.json")
    if not os.path.exists(pkg_path):
        open(pkg_path, "w", encoding="utf-8").write(json.dumps(pkg, indent=2))
    vcfg_path = os.path.join(dest, "vite.config.js")
    if not os.path.exists(vcfg_path):
        cfg = (
            "import { defineConfig } from 'vite\n"
            "import react from '@vitejs/plugin-react'\n"
            "export default defineConfig({ base: './', plugins: [react()], build: { outDir: 'dist' } })\n"
        ).replace("\n", "\n").replace(" '", " '")  # keep as plain text
        open(vcfg_path, "w", encoding="utf-8").write(
            "import { defineConfig } from 'vite'\n"
            "import react from '@vitejs/plugin-react'\n"
            "export default defineConfig({ base: './', plugins: [react()], build: { outDir: 'dist' } })\n"
        )

def scaffold_site_from_prompt(ctx, dest='./site', prompt='My App'):
    prompt = os.environ.get('OMAE_PROMPT', prompt)
    ensure_vite_react(dest)
    os.makedirs(os.path.join(dest,"src"),exist_ok=True)
    open(os.path.join(dest,"index.html"),"w",encoding="utf-8").write(
      "<!doctype html><html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width'>"
      "<title>Site</title></head><body><div id='root'></div><script type='module' src='/src/main.jsx'></script>"
      "</body></html>"
    )
    open(os.path.join(dest,"src","main.jsx"),"w",encoding="utf-8").write(
      "import React from 'react';import { createRoot } from 'react-dom/client';"
      "import App from './App.jsx';createRoot(document.getElementById('root')).render(<App />)"
    )
    hero = (prompt or "My App").replace('"','')[:120]
    app = (
      "import React from 'react\nexport default function App(){\n"
      "  return (\n"
      "    <div style={{fontFamily:'system-ui',background:'#0b1220',color:'#e5e7eb',minHeight:'100vh'}}>\n"
      "      <section style={{padding:24}}><h1 style={{fontSize:36,fontWeight:800}}"
      f">{hero}</h1><p>Generated by OMAe.</p></section>\n"
      "    </div>\n"
      "  )\n"
      "}\n"
    )
    open(os.path.join(dest,"src","App.jsx"),"w",encoding="utf-8").write(app)
    ctx['log'].append('scaffold_site_from_prompt: '+hero)
    return {'ok':True}

TEMPLATE_FILES_EXT = ('.html','.jsx','.js','.ts','.tsx','.css','.md')

def _subst_vars_in_file(fp, mapping):
    try:
        with open(fp,'r',encoding='utf-8') as f: s=f.read()
        for k,v in mapping.items():
            s=s.replace('{{'+k+'}}', v)
        with open(fp,'w',encoding='utf-8') as f: f.write(s)
    except Exception:
        pass

def _copy_template(template_id, dest):
    src=os.path.join('templates', template_id)
    if not os.path.isdir(src): return False
    if os.path.exists(dest): shutil.rmtree(dest)
    shutil.copytree(src, dest)
    return True

def scaffold_from_template(ctx, template_id='landing_saas', dest='./site', vars=None):
    template_id = os.environ.get('OMAE_TEMPLATE_ID', template_id)
    if vars is None: vars={}
    vars['title']   = os.environ.get('OMAE_TITLE',   vars.get('title','My App'))
    vars['tagline'] = os.environ.get('OMAE_TAGLINE', vars.get('tagline','Do more, faster.'))
    vars['cta']     = os.environ.get('OMAE_CTA',     vars.get('cta','Get Started'))
    ok=_copy_template(template_id, dest)
    if not ok:
        ctx['log'].append('TEMPLATE NOT FOUND: '+template_id); return {'ok':False}
    ensure_vite_react(dest)
    mapping={'TITLE': vars.get('title','My App'), 'TAGLINE': vars.get('tagline','Do more, faster.'), 'CTA': vars.get('cta','Get Started')}
    for root,dirs,files in os.walk(dest):
        for name in files:
            if name.endswith(TEMPLATE_FILES_EXT):
                _subst_vars_in_file(os.path.join(root,name), mapping)
    pub_src=os.path.join('templates', template_id, 'public')
    pub_dst=os.path.join(dest,'public')
    if os.path.isdir(pub_src):
        os.makedirs(pub_dst,exist_ok=True)
        for r,ds,fs in os.walk(pub_src):
            for f in fs:
                src=os.path.join(r,f)
                rel=os.path.relpath(src, pub_src)
                dst=os.path.join(pub_dst, rel)
                os.makedirs(os.path.dirname(dst),exist_ok=True)
                shutil.copy2(src, dst)
    ctx['log'].append('scaffold_from_template: '+template_id+' -> '+dest)
    return {'ok':True}

def generate_inspired_site(ctx, url='', template_id='landing_saas', dest='./site'):
    url = os.environ.get('OMAE_URL', url) or 'https://example.com'
    template_id = os.environ.get('OMAE_TEMPLATE_ID', template_id)
    try:
        host=urlparse(url).hostname or 'example.com'
        title = host.replace('www.','').split(':')[0].capitalize()
    except Exception:
        title = 'Your Site'
    return scaffold_from_template(ctx, template_id=template_id, dest=dest, vars={'title': title, 'tagline':'Describe your value prop here.', 'cta':'Get Started'})

def copy_csv_to_site_public(ctx, src_csv='data/sample_dashboard.csv', dest='./site'):
    pub=os.path.join(dest,'public'); os.makedirs(pub,exist_ok=True)
    dst=os.path.join(pub,'data.csv')
    if os.path.isfile(src_csv):
        shutil.copy2(src_csv, dst)
        ctx['log'].append('copied CSV -> '+dst)
        return {'ok':True}
    ctx['log'].append('CSV NOT FOUND: '+src_csv)
    return {'ok':False}

def inject_seo_meta(ctx, site_dir='./site', title='My Site', description='A great site'):
    title = os.environ.get('OMAE_TITLE', title)
    description = os.environ.get('OMAE_TAGLINE', description)
    idx=os.path.join(site_dir,'index.html')
    if os.path.isfile(idx):
        with open(idx,'r',encoding='utf-8') as f: html=f.read()
        meta = '<meta name="description" content="'+description+'">'
        if 'name="description"' not in html:
            html = html.replace('</head>', meta + '\n</head>')
        html = html.replace('<title>Site</title>', '<title>'+title+'</title>')
        with open(idx,'w',encoding='utf-8') as f: f.write(html)
        ctx['log'].append('SEO meta injected')
        return {'ok':True}
    ctx['log'].append('index.html not found for SEO inject')
    return {'ok':False}

def _write_release(relpath, content, binary=False):
    path=os.path.join('apps','publish','releases',relpath)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    if binary:
        with open(path,'wb') as f: f.write(content)
    else:
        with open(path,'w',encoding='utf-8') as f: f.write(content)
    return path

def research_compile_stub(ctx, topics=None, sources_file='data/research_sources.txt', out_html='research-report.html'):
    topics = topics or ["macro","ai","markets"]
    try:
        with open(sources_file,'r',encoding='utf-8') as f:
            sources=[line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        sources=["https://www.federalreserve.gov/","https://fred.stlouisfed.org/","https://www.sec.gov/"]
    html = ["<html><head><meta charset='utf-8'><title>Research Report</title><style>body{font-family:system-ui;padding:20px;background:#0b1220;color:#e5e7eb} .card{background:#0f172a;border:1px solid #1f2937;border-radius:12px;padding:14px;margin:10px 0}</style></head><body>"]
    html.append("<h1>Research Report (offline stub)</h1>")
    html.append("<p>Topics: "+", ".join(topics)+"</p>")
    html.append("<h3>Sources (not fetched in $0 mode):</h3><ul>")
    for s in sources: html.append("<li>"+s+"</li>")
    html.append("</ul><p class='card'>NOTE: In $0 mode we list sources and outline findings. Enable data TICs to fetch content.</p>")
    html.append("</body></html>")
    _write_release(out_html, "\n".join(html))
    ctx['log'].append("research report -> releases/"+out_html)
    return {'ok':True}

def market_monitor_eval_stub(ctx, symbols=None, quotes_file='data/quotes.json', pct_move_alert=3.0, out_json='monitor-alerts.json'):
    symbols = symbols or ["AAPL","MSFT","AMZN","SPY"]
    try:
        with open(quotes_file,'r',encoding='utf-8') as f: data=json.load(f)
    except FileNotFoundError:
        data={ s: { "price": 100.0, "prev_close": 100.0 } for s in symbols }
    alerts=[]
    for s in symbols:
        q=data.get(s) or {"price":100.0,"prev_close":100.0}
        price=q["price"]; prev=q["prev_close"]; change=0.0 if prev==0 else ((price-prev)/prev)*100.0
        if abs(change)>=pct_move_alert:
            alerts.append({"symbol":s,"price":price,"prev_close":prev,"pct_change":round(change,2)})
    _write_release(out_json, json.dumps({"threshold":pct_move_alert,"alerts":alerts,"ts":int(time.time())}, indent=2))
    ctx['log'].append("market monitor -> releases/"+out_json)
    return {'ok':True}

def options_analyze_stub(ctx, csv_path='data/options_sample.csv', out_html='options-report.html'):
    rows=[]
    try:
        with open(csv_path,'r',encoding='utf-8') as f:
            import csv as _csv
            dr=_csv.DictReader(f)
            for r in dr: rows.append(r)
    except FileNotFoundError:
        ctx['log'].append('options CSV not found')
        return {'ok':False}
    table = ["<table border='1' cellspacing='0' cellpadding='6'><tr><th>Symbol</th><th>Type</th><th>Strike</th><th>Underlying</th><th>Bid</th><th>Ask</th><th>Mid</th><th>Moneyness</th><th>Breakeven</th></tr>"]
    for r in rows[:200]:
        try:
            sym=r.get("symbol","?"); typ=r.get("type","call").lower()
            strike=float(r.get("strike",0)); und=float(r.get("underlying",0))
            bid=float(r.get("bid",0)); ask=float(r.get("ask",0))
            mid=(bid+ask)/2 if (bid and ask) else max(bid,ask)
            mny = (und/strike) if strike else 0.0
            breakeven = (strike + mid) if typ=="call" else (strike - mid)
            table.append("<tr><td>%s</td><td>%s</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.3f</td><td>%.2f</td></tr>" % (sym,typ,strike,und,bid,ask,mid,mny,breakeven))
        except Exception:
            continue
    table.append("</table>")
    html=(
      "<html><head><meta charset='utf-8'><title>Options Report</title>"
      "<style>body{font-family:system-ui;padding:20px;background:#0b1220;color:#e5e7eb} table{border-color:#1f2937} th,td{border-color:#1f2937}</style>"
      "</head><body><h1>Options Report (offline stub)</h1>"
      + "".join(table) +
      "<p>Data source: CSV at build time. For live, connect an options API TIC.</p></body></html>"
    )
    _write_release(out_html, html)
    ctx['log'].append("options analyze -> releases/"+out_html)
    return {'ok':True}

def portfolio_build_caps(ctx, tickers_file='data/tickers.txt', sectors_file='data/sectors.csv', max_weight=0.05, max_sector=0.20, out_csv='portfolio-proposal.csv'):
    try:
        with open(tickers_file,'r',encoding='utf-8') as f: tickers=[t.strip() for t in f if t.strip()]
    except FileNotFoundError:
        tickers=["VTI","VXUS","BND","VNQ","VWO","TLT","GLD","XLF","XLK","XLE","XLV"]
    sector_map={}
    try:
        with open(sectors_file,'r',encoding='utf-8') as f:
            import csv as _csv
            dr=_csv.DictReader(f)
            for r in dr: sector_map[r['ticker'].upper()] = r['sector']
    except FileNotFoundError:
        pass
    n=len(tickers); base=1.0/n if n else 0.0
    weights={t: min(base, max_weight) for t in tickers}
    total=sum(weights.values()); leftover=max(0.0, 1.0-total)
    while leftover>1e-9:
        under=[t for t in tickers if weights[t]+1e-9<max_weight]
        if not under: break
        add=leftover/len(under)
        for t in under:
            inc=min(add, max_weight-weights[t]); weights[t]+=inc; leftover-=inc
            if leftover<=1e-9: break
    def sector_totals(ws):
        tot={}
        for t,w in ws.items():
            s=sector_map.get(t,'Other'); tot[s]=tot.get(s,0.0)+w
        return tot
    def over(ws): return {s:v for s,v in sector_totals(ws).items() if v>max_sector+1e-9}
    guard=0
    while over(weights) and guard<20:
        guard+=1
        for s,v in over(weights).items():
            members=[t for t in tickers if sector_map.get(t,'Other')==s]
            ss=sum(weights[t] for t in members)
            if ss<=0: continue
            scale=max_sector/ss
            for t in members: weights[t]*=scale
        tot=sum(weights.values())
        if tot>0:
            for t in tickers: weights[t]/=tot
        overflow=sum(max(0.0, weights[t]-max_weight) for t in tickers)
        for t in tickers: weights[t]=min(weights[t], max_weight)
        while overflow>1e-9:
            under=[t for t in tickers if weights[t]+1e-9<max_weight]
            if not under: break
            add=overflow/len(under)
            for t in under:
                inc=min(add, max_weight-weights[t]); weights[t]+=inc; overflow-=inc
                if overflow<=1e-9: break
    lines=["ticker,sector,weight_pct"]
    for t in tickers:
        lines.append("%s,%s,%.2f" % (t, sector_map.get(t,'Other'), round(weights[t]*100,2)))
    _write_release(out_csv, "\n".join(lines))
    ctx['log'].append("portfolio proposal -> releases/"+out_csv)
    return {'ok':True}

def write_report(ctx, out='run_report.json'):
    with open(out,'w',encoding='utf-8') as f:
        json.dump({'log':ctx.get('log',[]),'skipped_nodes':ctx.get('skipped_nodes',[]),'ts':int(time.time())}, f, indent=2)
    _write_release('last_run_report.json', json.dumps({'log':ctx.get('log',[])}))
    return {'ok':True,'report':out}
